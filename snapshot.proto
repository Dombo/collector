syntax = "proto3";

import "google/protobuf/timestamp.proto";

package snapshot;

// DEFINITIONS
//
// - Reference: Term(s) that can be UPSERTed into the monitoring system, and is
//              referenced by its list index within other parts of the snapshot.
//
//              The goal here is that we can do a two-step processing of the data,
//              first we create/find all references and get their IDs, then we
//              just COPY all statistics into the database, replacing idx for ID.
//
// - Information: Data that is attached to a reference, at most once, and is not stored historically.
//                When processing this data can simply be UPDATEd after the initial UPSERT.
//
//                In some cases this data might also be provided at less frequent intervals than Statistics.
//
// - Statistic: Data that is attached to a reference, at most once, and is stored historically.
//              When processing this data can be COPYed after the initial UPSERT.
//
//              In case the input data is a counter, this will be normalized by the collector
//              before the snapshot is created, the recipient does not need to look at previous
//              values to find out what happened.
//
// - Event: Data that is attached to a reference, and can occur multiple times for one reference within the snapshot.
//          When processing this data can be COPYed after the initial UPSERT.

message Snapshot {
  // Basic information about this snapshot
  string collector_version = 1;
  google.protobuf.Timestamp collected_at = 2;

  // Per server (and hence snapshot)
  PostgresVersion postgres_version = 101;

  repeated LogLine logs = 102;
  repeated Backend backends = 103;
  repeated Setting settings = 104;

  repeated string database_references = 105; //  = ['mydb']
  repeated string user_references = 106; // = ['admin', 'otheruser', 'something_else']

  // Per database
  repeated QueryReference query_references = 200;
  repeated RelationReference relation_references = 201;
  repeated IndexReference index_references = 202;
  repeated FunctionReference function_references = 203;

  repeated QueryInformation query_informations = 210;
  repeated QueryStatistic query_statistics = 211;
  repeated QueryExplain query_explains = 212;

  repeated RelationInformation relation_informations = 220;
  repeated RelationStatistic relation_statistics = 221;
  repeated RelationBloatStatistic relation_bloat_statistics = 222;
  repeated RelationEvent relation_events = 223;

  repeated IndexInformation index_informations = 224;
  repeated IndexStatistic index_statistics = 225;
  repeated IndexBloatStatistic index_bloat_statistics = 226;

  repeated FunctionInformation function_informations = 227;
  repeated FunctionStatistic function_statistics = 228;
}

message NullString {
  bool valid = 1;
  string value = 2;
}

message RelationReference {
  int32 database_idx = 1;
  string schema_name = 2;
  string relation_name = 3;
}

message IndexReference {
  int32 database_idx = 1;
  string schema_name = 2;
  string index_name = 3;
}

message FunctionReference {
  int32 database_idx = 1;
  string schema_name = 2;
  string function_name = 3;
  string arguments = 4;
}

message QueryReference {
  int32 database_idx = 1;
  int32 user_idx = 2;
  bytes fingerprint = 3;
}

message QueryInformation {
  int32 query_ref = 1;

  string normalized_query = 2;
  repeated int64 query_ids = 3;
}

message QueryStatistic {
  int32 query_ref = 1;

  int64 calls = 2;
  double total_time = 3;
  int64 rows = 4;
  int64 shared_blks_hit = 5;
  int64 shared_blks_read = 6;
  int64 shared_blks_dirtied = 7;
  int64 shared_blks_written = 8;
  int64 local_blks_hit = 9;
  int64 local_blks_read = 10;
  int64 local_blks_dirtied = 11;
  int64 local_blks_written = 12;
  int64 temp_blks_read = 13;
  int64 temp_blks_written = 14;
  double blk_read_time = 15;
  double blk_write_time = 16;
}

message QueryExplain {
  int32 query_ref = 1;

  int64 occurred_at = 4;
  double runtime = 5;
  string explain_output = 6;
  string explain_error = 7;
}

message RelationInformation {
  int32 relation_ref = 1;

  string relation_type = 2;
  NullString view_definition = 3;

  repeated Column columns = 4;
  repeated Constraint constraints = 5;

  message Column {
    string name = 2;
    string data_type = 3;
    NullString default_value = 4;
    bool not_null = 5;
    int32 position = 6;
  }

  message Constraint {
    int32 foreign_relation_ref = 1;     // If a foreign key, the referenced table

    string name = 2;                    // Constraint name (not necessarily unique!)
    string type = 3;                    // c = check constraint, f = foreign key constraint, p = primary key constraint, u = unique constraint, t = constraint trigger, x = exclusion constraint
    string constraint_def = 4;          // Human-readable representation of the expression
    repeated int32 columns = 5;         // If a table constraint (including foreign keys, but not constraint triggers), list of the constrained columns
    repeated int32 foreign_columns = 6; // If a foreign key, list of the referenced columns
    string foreign_update_type = 7;     // Foreign key update action code: a = no action, r = restrict, c = cascade, n = set null, d = set default
    string foreign_delete_type = 8;     // Foreign key deletion action code: a = no action, r = restrict, c = cascade, n = set null, d = set default
    string foreign_match_type = 9;      // Foreign key match type: f = full, p = partial, s = simple
  }
}

message RelationStatistic {
  int32 relation_ref = 1;

  int64 size_bytes = 2;
  int64 seq_scan = 3;             // Number of sequential scans initiated on this table
  int64 seq_tup_read = 4;         // Number of live rows fetched by sequential scans
  int64 idx_scan = 5;             // Number of index scans initiated on this table
  int64 idx_tup_fetch = 6;        // Number of live rows fetched by index scans
  int64 n_tup_ins = 7;            // Number of rows inserted
  int64 n_tup_upd = 8;            // Number of rows updated
  int64 n_tup_del = 9;            // Number of rows deleted
  int64 n_tup_hot_upd = 10;       // Number of rows HOT updated (i.e., with no separate index update required)
  int64 n_live_tup = 11;          // Estimated number of live rows
  int64 n_dead_tup = 12;          // Estimated number of dead rows
  int64 n_mod_since_analyze = 13; // Estimated number of rows modified since this table was last analyzed
  int64 heap_blks_read = 18;      // Number of disk blocks read from this table
  int64 heap_blks_hit = 19;       // Number of buffer hits in this table
  int64 idx_blks_read = 20;       // Number of disk blocks read from all indexes on this table
  int64 idx_blks_hit = 21;        // Number of buffer hits in all indexes on this table
  int64 toast_blks_read = 22;     // Number of disk blocks read from this table's TOAST table (if any)
  int64 toast_blks_hit = 23;      // Number of buffer hits in this table's TOAST table (if any)
  int64 tidx_blks_read = 24;      // Number of disk blocks read from this table's TOAST table indexes (if any)
  int64 tidx_blks_hit = 25;       // Number of buffer hits in this table's TOAST table indexes (if any)
}

message RelationEvent {
  enum EventType {
    MANUAL_VACUUM = 0;  // Manually vacuumed (not counting VACUUM FULL)
    AUTO_VACUUM = 1;    // Vacuumed by the autovacuum daemon
    MANUAL_ANALYZE = 2; // Manually analyzed
    AUTO_ANALYZE = 3;   // Analyzed by the autovacuum daemon
  }

  int32 relation_ref = 1;
  EventType type = 2;
  google.protobuf.Timestamp occurred_at = 3;
  bool approximate_occurred_at = 4; // In case the "occurred_at" field is approximate, because more than one kind of this event happened during the snapshot
}

message RelationBloatStatistic {
  int32 relation_ref = 1;

  int64 wasted_bytes = 2;
  int64 size_bytes = 3;
}

message IndexInformation {
  int32 index_ref = 1;
  int32 relation_ref = 2;

  repeated int32 columns = 3;
  string index_def = 4;
  NullString constraint_def = 5;

  bool is_primary = 6;
  bool is_unique = 7;
  bool is_valid = 8;
}

message IndexStatistic {
  int32 index_ref = 1;

  int64 size_bytes = 2;
  int64 idx_scan = 3;
  int64 idx_tup_read = 4;
  int64 idx_tup_fetch = 6;
  int64 idx_blks_read = 7;
  int64 idx_blks_hit = 8;
}

message IndexBloatStatistic {
  int32 index_ref = 1;

  int64 wasted_bytes = 2;
  int64 size_bytes = 3;
}
message FunctionInformation {
  int32 function_ref = 1;

  string language = 3;
  string source = 4;
  string source_bin = 5;
  NullString config = 6;
  string result = 8;

  bool aggregate = 9;
  bool window = 10;
  bool security_definer = 11;
  bool leakproof = 12;
  bool strict = 13;
  bool returns_set = 14;
  string volatile = 15;
}

message FunctionStatistic {
  int32 function_ref = 1;

  int64 calls = 2;
  double total_time = 3;
  double self_time = 4;
}

message PostgresVersion {
  string full = 1;
  string short = 2;
  int64 numeric = 3;
}

message LogLine {
  int64 occurred_at = 1;
  SourceType source = 2;
  NullString client_ip = 3;
  string log_level = 4;
  int32 backend_pid = 5;
  string content = 6;
  repeated LogLine additional_lines = 7;

  enum SourceType {
    PostgresSource = 0;
    AmazonRdsSource = 1;
  }
}

message Setting {
  string name = 1;
  string current_value = 2;
  NullString unit = 3;
  NullString boot_value = 4;
  NullString reset_value = 5;
  NullString source = 6;
  NullString source_file = 7;
  NullString source_line = 8;
}

message Backend {
  int64 pid = 1;
  string username = 2;
  string application_name = 3;
  string client_addr = 4;

  google.protobuf.Timestamp backend_start = 5;
  google.protobuf.Timestamp xact_start = 6;
  google.protobuf.Timestamp query_start = 7;
  google.protobuf.Timestamp state_change = 8;

  bool waiting = 9;
  string state = 10;
  string normalized_query = 11;
}

message System {
  // TODO
}
